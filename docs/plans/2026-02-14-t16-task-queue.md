# T16: Task Queue — Redis with Priority + Queue Isolation

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create a `ProcessTask` job that dispatches tasks to the correct Redis queue (`vunnix-server` or `vunnix-runner-{priority}`) based on task type, plus a `TaskDispatchService` that wires webhook events to Task creation + queue dispatch.

**Architecture:** Two queue groups per D134. Server-side tasks (e.g., `prd_creation`) go to `vunnix-server` for immediate processing. Runner tasks (e.g., `code_review`, `feature_dev`) go to `vunnix-runner-high`, `vunnix-runner-normal`, or `vunnix-runner-low` based on the `TaskPriority` enum. The `TaskDispatchService` creates the `Task` model, transitions it through `received → queued`, and dispatches the `ProcessTask` job. The Docker Compose workers already exist — this task wires the Laravel side.

**Tech Stack:** Laravel 11 Queue (Redis driver), Pest tests, existing Task model + enums

---

### Task 1: Add `executionMode()` method to `TaskType` enum

**Files:**
- Modify: `app/Enums/TaskType.php`
- Test: `tests/Unit/Enums/TaskTypeTest.php`

**Step 1: Write the failing test**

Create `tests/Unit/Enums/TaskTypeTest.php`:

```php
<?php

use App\Enums\TaskType;

it('returns runner mode for code review', function () {
    expect(TaskType::CodeReview->executionMode())->toBe('runner');
});

it('returns runner mode for feature dev', function () {
    expect(TaskType::FeatureDev->executionMode())->toBe('runner');
});

it('returns runner mode for issue discussion', function () {
    expect(TaskType::IssueDiscussion->executionMode())->toBe('runner');
});

it('returns runner mode for UI adjustment', function () {
    expect(TaskType::UiAdjustment->executionMode())->toBe('runner');
});

it('returns runner mode for security audit', function () {
    expect(TaskType::SecurityAudit->executionMode())->toBe('runner');
});

it('returns server mode for PRD creation', function () {
    expect(TaskType::PrdCreation->executionMode())->toBe('server');
});
```

**Step 2: Run test to verify it fails**

Run: `php artisan test tests/Unit/Enums/TaskTypeTest.php`
Expected: FAIL — `executionMode()` method doesn't exist

**Step 3: Write minimal implementation**

Add to `app/Enums/TaskType.php`:

```php
public function executionMode(): string
{
    return match ($this) {
        self::PrdCreation => 'server',
        default => 'runner',
    };
}
```

**Step 4: Run test to verify it passes**

Run: `php artisan test tests/Unit/Enums/TaskTypeTest.php`
Expected: PASS (6 tests)

---

### Task 2: Add `queueName()` method to `TaskPriority` enum

**Files:**
- Modify: `app/Enums/TaskPriority.php`
- Test: `tests/Unit/Enums/TaskPriorityTest.php`

**Step 1: Write the failing test**

Create `tests/Unit/Enums/TaskPriorityTest.php`:

```php
<?php

use App\Enums\TaskPriority;

it('returns high runner queue name', function () {
    expect(TaskPriority::High->runnerQueueName())->toBe('vunnix-runner-high');
});

it('returns normal runner queue name', function () {
    expect(TaskPriority::Normal->runnerQueueName())->toBe('vunnix-runner-normal');
});

it('returns low runner queue name', function () {
    expect(TaskPriority::Low->runnerQueueName())->toBe('vunnix-runner-low');
});
```

**Step 2: Run test to verify it fails**

Run: `php artisan test tests/Unit/Enums/TaskPriorityTest.php`
Expected: FAIL — `runnerQueueName()` method doesn't exist

**Step 3: Write minimal implementation**

Add to `app/Enums/TaskPriority.php`:

```php
public function runnerQueueName(): string
{
    return 'vunnix-runner-' . $this->value;
}
```

**Step 4: Run test to verify it passes**

Run: `php artisan test tests/Unit/Enums/TaskPriorityTest.php`
Expected: PASS (3 tests)

---

### Task 3: Create `ProcessTask` job with queue routing

**Files:**
- Create: `app/Jobs/ProcessTask.php`
- Test: `tests/Unit/Jobs/ProcessTaskTest.php`

**Step 1: Write the failing test**

Create `tests/Unit/Jobs/ProcessTaskTest.php`:

```php
<?php

use App\Enums\TaskPriority;
use App\Enums\TaskType;
use App\Jobs\ProcessTask;
use App\Models\Task;

it('routes server-side task to vunnix-server queue', function () {
    $task = Task::factory()->make([
        'type' => TaskType::PrdCreation,
        'priority' => TaskPriority::Normal,
    ]);

    $job = new ProcessTask($task->id);
    $job->resolveQueue($task);

    expect($job->queue)->toBe('vunnix-server');
});

it('routes runner task to priority-specific queue', function () {
    $task = Task::factory()->make([
        'type' => TaskType::CodeReview,
        'priority' => TaskPriority::High,
    ]);

    $job = new ProcessTask($task->id);
    $job->resolveQueue($task);

    expect($job->queue)->toBe('vunnix-runner-high');
});

it('routes normal priority runner task correctly', function () {
    $task = Task::factory()->make([
        'type' => TaskType::CodeReview,
        'priority' => TaskPriority::Normal,
    ]);

    $job = new ProcessTask($task->id);
    $job->resolveQueue($task);

    expect($job->queue)->toBe('vunnix-runner-normal');
});

it('routes low priority runner task correctly', function () {
    $task = Task::factory()->make([
        'type' => TaskType::FeatureDev,
        'priority' => TaskPriority::Low,
    ]);

    $job = new ProcessTask($task->id);
    $job->resolveQueue($task);

    expect($job->queue)->toBe('vunnix-runner-low');
});
```

**Step 2: Run test to verify it fails**

Run: `php artisan test tests/Unit/Jobs/ProcessTaskTest.php`
Expected: FAIL — ProcessTask class doesn't exist

**Step 3: Write minimal implementation**

Create `app/Jobs/ProcessTask.php`:

```php
<?php

namespace App\Jobs;

use App\Models\Task;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;
use Illuminate\Support\Facades\Log;

/**
 * Dispatched when a task transitions to 'queued'.
 *
 * Queue routing (D134):
 * - Server-side tasks (PrdCreation) → vunnix-server
 * - Runner tasks → vunnix-runner-{priority} (high/normal/low)
 *
 * The handle() method is a stub — T17 (Task Dispatcher) will implement
 * strategy selection and execution mode routing.
 */
class ProcessTask implements ShouldQueue
{
    use Queueable;

    public function __construct(
        public readonly int $taskId,
    ) {}

    /**
     * Resolve the correct queue name based on task type and priority.
     *
     * Called before dispatch to set $this->queue.
     */
    public function resolveQueue(Task $task): void
    {
        if ($task->type->executionMode() === 'server') {
            $this->queue = 'vunnix-server';
        } else {
            $this->queue = $task->priority->runnerQueueName();
        }
    }

    /**
     * Execute the job.
     *
     * Stub implementation — T17 (Task Dispatcher) will add strategy
     * selection and pipeline trigger / server-side execution logic.
     */
    public function handle(): void
    {
        $task = Task::find($this->taskId);

        if ($task === null) {
            Log::warning('ProcessTask: task not found', ['task_id' => $this->taskId]);

            return;
        }

        if ($task->isTerminal()) {
            Log::info('ProcessTask: task already in terminal state, skipping', [
                'task_id' => $this->taskId,
                'status' => $task->status->value,
            ]);

            return;
        }

        Log::info('ProcessTask: picked up task (T17 will implement dispatch logic)', [
            'task_id' => $this->taskId,
            'type' => $task->type->value,
            'priority' => $task->priority->value,
            'execution_mode' => $task->type->executionMode(),
        ]);
    }
}
```

**Step 4: Run test to verify it passes**

Run: `php artisan test tests/Unit/Jobs/ProcessTaskTest.php`
Expected: PASS (4 tests)

---

### Task 4: Create `TaskDispatchService`

**Files:**
- Create: `app/Services/TaskDispatchService.php`
- Test: `tests/Feature/Services/TaskDispatchServiceTest.php`

This is the core service that creates Task models from routing results and dispatches them to the queue.

**Step 1: Write the failing test**

Create `tests/Feature/Services/TaskDispatchServiceTest.php`:

```php
<?php

use App\Enums\TaskOrigin;
use App\Enums\TaskPriority;
use App\Enums\TaskStatus;
use App\Enums\TaskType;
use App\Events\Webhook\MergeRequestOpened;
use App\Events\Webhook\NoteOnIssue;
use App\Events\Webhook\NoteOnMR;
use App\Events\Webhook\IssueLabelChanged;
use App\Jobs\ProcessTask;
use App\Models\Project;
use App\Models\Task;
use App\Models\User;
use App\Services\RoutingResult;
use App\Services\TaskDispatchService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Queue;

uses(RefreshDatabase::class);

function makeRoutingResult(string $intent, string $priority, $event): RoutingResult
{
    return new RoutingResult($intent, $priority, $event);
}

// ─── Intent → TaskType mapping ─────────────────────────────────────

it('maps auto_review intent to CodeReview type', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new MergeRequestOpened($project->id, $project->gitlab_project_id, [], 1, 'feature', 'main', $user->gitlab_user_id, 'abc123');
    $result = makeRoutingResult('auto_review', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->type)->toBe(TaskType::CodeReview);
});

it('maps on_demand_review intent to CodeReview type', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new NoteOnMR($project->id, $project->gitlab_project_id, [], 1, '@ai review', $user->gitlab_user_id);
    $result = makeRoutingResult('on_demand_review', 'high', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->type)->toBe(TaskType::CodeReview)
        ->and($task->priority)->toBe(TaskPriority::High);
});

it('maps issue_discussion intent to IssueDiscussion type', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new NoteOnIssue($project->id, $project->gitlab_project_id, [], 10, '@ai explain', $user->gitlab_user_id);
    $result = makeRoutingResult('issue_discussion', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->type)->toBe(TaskType::IssueDiscussion);
});

it('maps feature_dev intent to FeatureDev type', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new IssueLabelChanged($project->id, $project->gitlab_project_id, [], 10, 'update', $user->gitlab_user_id, ['ai::develop']);
    $result = makeRoutingResult('feature_dev', 'low', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->type)->toBe(TaskType::FeatureDev)
        ->and($task->priority)->toBe(TaskPriority::Low);
});

// ─── Task lifecycle ────────────────────────────────────────────────

it('creates task in queued status (received → queued transition)', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new MergeRequestOpened($project->id, $project->gitlab_project_id, [], 1, 'feature', 'main', $user->gitlab_user_id, 'abc123');
    $result = makeRoutingResult('auto_review', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->status)->toBe(TaskStatus::Queued);
});

it('sets origin to webhook', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new MergeRequestOpened($project->id, $project->gitlab_project_id, [], 1, 'feature', 'main', $user->gitlab_user_id, 'abc123');
    $result = makeRoutingResult('auto_review', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->origin)->toBe(TaskOrigin::Webhook);
});

it('persists correct GitLab context for MR events', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new MergeRequestOpened($project->id, $project->gitlab_project_id, [], 42, 'feature', 'main', $user->gitlab_user_id, 'deadbeef');
    $result = makeRoutingResult('auto_review', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->project_id)->toBe($project->id)
        ->and($task->mr_iid)->toBe(42)
        ->and($task->commit_sha)->toBe('deadbeef');
});

it('persists correct GitLab context for Issue events', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new NoteOnIssue($project->id, $project->gitlab_project_id, [], 99, '@ai help', $user->gitlab_user_id);
    $result = makeRoutingResult('issue_discussion', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task->issue_iid)->toBe(99)
        ->and($task->mr_iid)->toBeNull();
});

// ─── Job dispatch ──────────────────────────────────────────────────

it('dispatches ProcessTask job to vunnix-runner-normal for code review', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new MergeRequestOpened($project->id, $project->gitlab_project_id, [], 1, 'feature', 'main', $user->gitlab_user_id, 'abc123');
    $result = makeRoutingResult('auto_review', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $service->dispatch($result);

    Queue::assertPushedOn('vunnix-runner-normal', ProcessTask::class);
});

it('dispatches ProcessTask job to vunnix-runner-high for on-demand review', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new NoteOnMR($project->id, $project->gitlab_project_id, [], 1, '@ai review', $user->gitlab_user_id);
    $result = makeRoutingResult('on_demand_review', 'high', $event);

    $service = app(TaskDispatchService::class);
    $service->dispatch($result);

    Queue::assertPushedOn('vunnix-runner-high', ProcessTask::class);
});

it('dispatches ProcessTask job to vunnix-runner-low for feature dev', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new IssueLabelChanged($project->id, $project->gitlab_project_id, [], 10, 'update', $user->gitlab_user_id, ['ai::develop']);
    $result = makeRoutingResult('feature_dev', 'low', $event);

    $service = app(TaskDispatchService::class);
    $service->dispatch($result);

    Queue::assertPushedOn('vunnix-runner-low', ProcessTask::class);
});

// ─── Transition logging ────────────────────────────────────────────

it('logs received → queued transition', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new MergeRequestOpened($project->id, $project->gitlab_project_id, [], 1, 'feature', 'main', $user->gitlab_user_id, 'abc123');
    $result = makeRoutingResult('auto_review', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    $this->assertDatabaseHas('task_transition_logs', [
        'task_id' => $task->id,
        'from_status' => 'received',
        'to_status' => 'queued',
    ]);
});

// ─── Skips non-dispatchable intents ────────────────────────────────

it('returns null for help_response intent (already handled by PostHelpResponse)', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new NoteOnMR($project->id, $project->gitlab_project_id, [], 1, '@ai foo', $user->gitlab_user_id);
    $result = makeRoutingResult('help_response', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task)->toBeNull();
    Queue::assertNothingPushed();
});

it('returns null for acceptance_tracking intent (not a task)', function () {
    Queue::fake();
    $project = Project::factory()->create();
    $user = User::factory()->create();

    $event = new \App\Events\Webhook\MergeRequestMerged($project->id, $project->gitlab_project_id, [], 1, 'feature', 'main', $user->gitlab_user_id, 'abc123');
    $result = makeRoutingResult('acceptance_tracking', 'normal', $event);

    $service = app(TaskDispatchService::class);
    $task = $service->dispatch($result);

    expect($task)->toBeNull();
    Queue::assertNothingPushed();
});
```

**Step 2: Run test to verify it fails**

Run: `php artisan test tests/Feature/Services/TaskDispatchServiceTest.php`
Expected: FAIL — TaskDispatchService class doesn't exist

**Step 3: Write minimal implementation**

Create `app/Services/TaskDispatchService.php`:

```php
<?php

namespace App\Services;

use App\Enums\TaskOrigin;
use App\Enums\TaskPriority;
use App\Enums\TaskStatus;
use App\Enums\TaskType;
use App\Events\Webhook\IssueLabelChanged;
use App\Events\Webhook\MergeRequestMerged;
use App\Events\Webhook\MergeRequestOpened;
use App\Events\Webhook\MergeRequestUpdated;
use App\Events\Webhook\NoteOnIssue;
use App\Events\Webhook\NoteOnMR;
use App\Events\Webhook\PushToMRBranch;
use App\Events\Webhook\WebhookEvent;
use App\Jobs\ProcessTask;
use App\Models\Task;
use App\Models\User;
use Illuminate\Support\Facades\Log;

/**
 * Creates Task models from routing results and dispatches them to the queue.
 *
 * This service bridges the gap between the EventRouter (T13) and the
 * ProcessTask job (T16). It:
 * 1. Maps intents to TaskType enums
 * 2. Extracts GitLab context (MR IID, Issue IID, commit SHA) from events
 * 3. Resolves the user from GitLab author ID
 * 4. Creates the Task in 'received' state, then transitions to 'queued'
 * 5. Dispatches ProcessTask to the correct queue (D134)
 */
class TaskDispatchService
{
    /**
     * Intent → TaskType mapping.
     *
     * Intents not listed here are non-dispatchable (e.g., help_response
     * is handled inline by PostHelpResponse, acceptance_tracking is T86).
     */
    private const INTENT_TO_TYPE = [
        'auto_review' => TaskType::CodeReview,
        'on_demand_review' => TaskType::CodeReview,
        'incremental_review' => TaskType::CodeReview,
        'improve' => TaskType::CodeReview,
        'ask_command' => TaskType::IssueDiscussion,
        'issue_discussion' => TaskType::IssueDiscussion,
        'feature_dev' => TaskType::FeatureDev,
    ];

    /**
     * Dispatch a routing result as a queued task.
     *
     * Returns the created Task, or null if the intent is not dispatchable.
     */
    public function dispatch(RoutingResult $routingResult): ?Task
    {
        $taskType = self::INTENT_TO_TYPE[$routingResult->intent] ?? null;

        if ($taskType === null) {
            Log::debug('TaskDispatchService: non-dispatchable intent, skipping', [
                'intent' => $routingResult->intent,
            ]);

            return null;
        }

        $event = $routingResult->event;
        $priority = TaskPriority::from($routingResult->priority);

        // Resolve user from GitLab author ID
        $userId = $this->resolveUserId($event);

        // Create Task in 'received' state
        $task = Task::create([
            'type' => $taskType,
            'origin' => TaskOrigin::Webhook,
            'user_id' => $userId,
            'project_id' => $event->projectId,
            'priority' => $priority,
            'status' => TaskStatus::Received,
            'mr_iid' => $this->extractMrIid($event),
            'issue_iid' => $this->extractIssueIid($event),
            'commit_sha' => $this->extractCommitSha($event),
        ]);

        // Transition received → queued (fires TaskObserver for logging)
        $task->transitionTo(TaskStatus::Queued);

        // Dispatch to correct queue
        $job = new ProcessTask($task->id);
        $job->resolveQueue($task);
        dispatch($job);

        Log::info('TaskDispatchService: dispatched task', [
            'task_id' => $task->id,
            'type' => $taskType->value,
            'priority' => $priority->value,
            'queue' => $job->queue,
            'intent' => $routingResult->intent,
        ]);

        return $task;
    }

    private function resolveUserId(WebhookEvent $event): ?int
    {
        $gitlabUserId = $this->extractAuthorId($event);

        if ($gitlabUserId === null) {
            return null;
        }

        return User::where('gitlab_user_id', $gitlabUserId)->value('id');
    }

    private function extractAuthorId(WebhookEvent $event): ?int
    {
        return match (true) {
            $event instanceof MergeRequestOpened,
            $event instanceof MergeRequestUpdated,
            $event instanceof MergeRequestMerged => $event->authorId,
            $event instanceof NoteOnMR => $event->authorId,
            $event instanceof NoteOnIssue => $event->authorId,
            $event instanceof IssueLabelChanged => $event->authorId,
            $event instanceof PushToMRBranch => $event->userId,
            default => null,
        };
    }

    private function extractMrIid(WebhookEvent $event): ?int
    {
        return match (true) {
            $event instanceof MergeRequestOpened,
            $event instanceof MergeRequestUpdated,
            $event instanceof MergeRequestMerged => $event->mergeRequestIid,
            $event instanceof NoteOnMR => $event->mergeRequestIid,
            default => null,
        };
    }

    private function extractIssueIid(WebhookEvent $event): ?int
    {
        return match (true) {
            $event instanceof NoteOnIssue => $event->issueIid,
            $event instanceof IssueLabelChanged => $event->issueIid,
            default => null,
        };
    }

    private function extractCommitSha(WebhookEvent $event): ?string
    {
        return match (true) {
            $event instanceof MergeRequestOpened,
            $event instanceof MergeRequestUpdated,
            $event instanceof MergeRequestMerged => $event->lastCommitSha,
            $event instanceof PushToMRBranch => $event->afterSha,
            default => null,
        };
    }
}
```

**Step 4: Run test to verify it passes**

Run: `php artisan test tests/Feature/Services/TaskDispatchServiceTest.php`
Expected: PASS (all tests)

---

### Task 5: Add queue constants to a shared location

**Files:**
- Create: `app/Support/QueueNames.php`
- Modify: `app/Jobs/PostHelpResponse.php` (use constant instead of string literal)
- Modify: `app/Jobs/ProcessTask.php` (use constants)

**Step 1: Create constants class**

Create `app/Support/QueueNames.php`:

```php
<?php

namespace App\Support;

/**
 * Queue name constants (D134).
 *
 * Two queue groups:
 * - vunnix-server: Immediate server-side tasks (Issue creation, help responses)
 * - vunnix-runner-{priority}: CI pipeline tasks processed by priority
 *
 * These names must match docker-compose.yml worker --queue arguments.
 */
final class QueueNames
{
    public const SERVER = 'vunnix-server';

    public const RUNNER_HIGH = 'vunnix-runner-high';

    public const RUNNER_NORMAL = 'vunnix-runner-normal';

    public const RUNNER_LOW = 'vunnix-runner-low';
}
```

**Step 2: Update PostHelpResponse to use constant**

In `app/Jobs/PostHelpResponse.php`, change the constructor:

```php
// Before
$this->onQueue('vunnix-server');

// After
$this->onQueue(\App\Support\QueueNames::SERVER);
```

**Step 3: Update ProcessTask to use constants**

In `app/Jobs/ProcessTask.php`, update `resolveQueue()`:

```php
use App\Support\QueueNames;

public function resolveQueue(Task $task): void
{
    if ($task->type->executionMode() === 'server') {
        $this->queue = QueueNames::SERVER;
    } else {
        $this->queue = $task->priority->runnerQueueName();
    }
}
```

**Step 4: Run all tests to confirm nothing breaks**

Run: `php artisan test`
Expected: All tests pass

---

### Task 6: Update verify_m2.py with T16 structural checks

**Files:**
- Modify: `verify/verify_m2.py`

**Step 1: Add T16 section to verify_m2.py**

Add before the runtime checks section:

```python
# ============================================================
#  T16: Task queue — Redis with priority + queue isolation
# ============================================================
section("T16: Task Queue — Redis Priority + Queue Isolation")

# ProcessTask job
checker.check(
    "ProcessTask job exists",
    file_exists("app/Jobs/ProcessTask.php"),
)
checker.check(
    "ProcessTask implements ShouldQueue",
    file_contains("app/Jobs/ProcessTask.php", "ShouldQueue"),
)
checker.check(
    "ProcessTask has resolveQueue() method",
    file_contains("app/Jobs/ProcessTask.php", "function resolveQueue("),
)
checker.check(
    "ProcessTask routes to vunnix-server for server tasks",
    file_contains("app/Jobs/ProcessTask.php", "vunnix-server"),
)
checker.check(
    "ProcessTask routes to runner queues for runner tasks",
    file_contains("app/Jobs/ProcessTask.php", "runnerQueueName"),
)

# TaskDispatchService
checker.check(
    "TaskDispatchService exists",
    file_exists("app/Services/TaskDispatchService.php"),
)
checker.check(
    "TaskDispatchService has dispatch() method",
    file_contains("app/Services/TaskDispatchService.php", "function dispatch("),
)
checker.check(
    "TaskDispatchService maps intents to TaskType",
    file_contains("app/Services/TaskDispatchService.php", "INTENT_TO_TYPE"),
)
checker.check(
    "TaskDispatchService creates Task in received status",
    file_contains("app/Services/TaskDispatchService.php", "TaskStatus::Received"),
)
checker.check(
    "TaskDispatchService transitions to queued",
    file_contains("app/Services/TaskDispatchService.php", "TaskStatus::Queued"),
)
checker.check(
    "TaskDispatchService dispatches ProcessTask",
    file_contains("app/Services/TaskDispatchService.php", "ProcessTask"),
)

# TaskType execution mode
checker.check(
    "TaskType has executionMode() method",
    file_contains("app/Enums/TaskType.php", "function executionMode()"),
)
checker.check(
    "TaskType maps PrdCreation to server mode",
    file_contains("app/Enums/TaskType.php", "'server'"),
)

# TaskPriority queue naming
checker.check(
    "TaskPriority has runnerQueueName() method",
    file_contains("app/Enums/TaskPriority.php", "function runnerQueueName()"),
)
checker.check(
    "TaskPriority generates vunnix-runner prefix",
    file_contains("app/Enums/TaskPriority.php", "vunnix-runner-"),
)

# QueueNames constants
checker.check(
    "QueueNames constants class exists",
    file_exists("app/Support/QueueNames.php"),
)
checker.check(
    "QueueNames defines SERVER constant",
    file_contains("app/Support/QueueNames.php", "SERVER"),
)
checker.check(
    "QueueNames defines RUNNER_ constants",
    file_contains("app/Support/QueueNames.php", "RUNNER_HIGH"),
)

# Tests
checker.check(
    "TaskType unit test exists",
    file_exists("tests/Unit/Enums/TaskTypeTest.php"),
)
checker.check(
    "TaskPriority unit test exists",
    file_exists("tests/Unit/Enums/TaskPriorityTest.php"),
)
checker.check(
    "ProcessTask unit test exists",
    file_exists("tests/Unit/Jobs/ProcessTaskTest.php"),
)
checker.check(
    "TaskDispatchService feature test exists",
    file_exists("tests/Feature/Services/TaskDispatchServiceTest.php"),
)
```

**Step 2: Run verification**

Run: `python3 verify/verify_m2.py`
Expected: All T16 checks pass

---

### Task 7: Run full verification + commit

**Step 1: Run all Laravel tests**

Run: `php artisan test`
Expected: All tests pass

**Step 2: Run M2 structural verification**

Run: `python3 verify/verify_m2.py`
Expected: All checks pass

**Step 3: Commit**

```bash
git add app/Enums/TaskType.php app/Enums/TaskPriority.php \
  app/Jobs/ProcessTask.php app/Jobs/PostHelpResponse.php \
  app/Services/TaskDispatchService.php app/Support/QueueNames.php \
  tests/Unit/Enums/TaskTypeTest.php tests/Unit/Enums/TaskPriorityTest.php \
  tests/Unit/Jobs/ProcessTaskTest.php tests/Feature/Services/TaskDispatchServiceTest.php \
  verify/verify_m2.py

git commit --no-gpg-sign -m "$(cat <<'EOF'
T16: Add task queue with Redis priority and queue isolation (D134)

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```
