# Vunnix X3 Iteration Architecture (Staff-Level Proposal)

Date: 2026-02-19  
Author: Staff Architecture Analysis

## 1. Executive Summary

Vunnix should remain a **modular monolith**, but move from horizontal layering (controllers/services/jobs/stores) to **capability-oriented vertical slices** with strict contracts.  
This yields 3x delivery speed by reducing cross-module edits, lowering regression blast radius, and enabling parallel teams to ship independently.

Do **not** split into microservices now. The bottleneck is coupling and workflow complexity, not host-level scale.

---

## 2. Current Bottlenecks (Observed in Repository)

### 2.1 High coupling in core orchestration paths

- Webhook + routing + dispatch concerns are distributed across multiple broad classes:
  - `app/Http/Controllers/WebhookController.php`
  - `app/Services/EventRouter.php`
  - `app/Services/TaskDispatchService.php`
  - `app/Services/TaskDispatcher.php`
  - `app/Jobs/ProcessTaskResult.php`
- Result: adding one new intent/task type typically requires touching controller, router, dispatcher, job dispatch matrix, and tests in several directories.

### 2.2 “God service” tendencies

- Large and multi-responsibility services:
  - `app/Services/GitLabClient.php` (~747 lines)
  - `app/Services/AlertEventService.php` (~794 lines)
  - `app/Agents/VunnixAgent.php` (~486 lines)
- Result: low cohesion and high change collision frequency.

### 2.3 API and frontend domain sprawl

- Single API route file handles many bounded contexts (`routes/api.php`, 67 route definitions).
- Broad frontend stores aggregate many concerns:
  - `resources/js/stores/conversations.ts` (~912 lines)
  - `resources/js/stores/admin.ts` (~519 lines)
- Result: a feature in one area can destabilize unrelated behavior; test files become very large.

### 2.4 Monolithic test and verification paths

- Large test surface is excellent for quality, but currently expensive for fast iteration when changes are localized.
- Existing CI is quality-strong but mostly full-suite lane based (`.github/workflows/tests.yml`), limiting incremental feedback speed.

### 2.5 Runtime mode mismatch for developer inner loop

- Production parity stack relies on Octane/worker lifecycles; documented learning indicates frequent full container recycle for code/env updates.
- Result: slower local feedback loops and context switches.

---

## 3. Target Architecture for 3x Iteration Speed

## 3.1 Architectural style: Modular Monolith + Workflow Kernel

Adopt a **workflow kernel** with **plug-in handlers** per capability.

### New top-level module layout

```text
app/Modules/
  Chat/
  WebhookIntake/
  TaskOrchestration/
  GitLabIntegration/
  ReviewExecution/
  FeatureExecution/
  Observability/
  AdminGovernance/
  Shared/
```

Boundary ownership and guardrail rules are documented in `app/Modules/README.md`.

Each module owns:

- `Domain/` (entities, value objects, invariants)
- `Application/` (use cases, command/query handlers)
- `Infrastructure/` (Eloquent, HTTP adapters, queue/broadcast implementations)
- `Api/` (controllers, requests, resources scoped to the module)

### Rule

- Module-to-module calls happen through **published interfaces** (`Contracts`), not direct concrete class usage.
- Cross-module data exchange uses stable DTOs/events.

## 3.2 Intent/Task plug-in model (core speed lever)

Replace intent/task switch logic with registries:

- `IntentClassifierRegistry`
- `TaskHandlerRegistry`
- `ResultPublisherRegistry`

Adding a new intent should require:

1. Register classifier
2. Register task handler
3. Register result publisher

No edits to core controller/dispatcher flow.

## 3.3 Ports and adapters around external systems

Define explicit ports:

- `GitLabPort`
- `AiProviderPort`
- `PipelineExecutorPort`
- `RealtimePort`
- `NotificationPort`

Current `GitLabClient` becomes adapter set by capability (issues, mrs, notes, repos, pipelines) to reduce coupling and test setup size.

## 3.4 Event + outbox boundary for asynchronous reliability

Introduce internal event envelope:

- `event_id`, `event_type`, `aggregate_id`, `occurred_at`, `payload`, `schema_version`

Use an outbox table for state-change events consumed by jobs/realtime publishers.  
This decouples “business state commit” from “side effects” and stabilizes retries.

## 3.5 Frontend vertical slices

Restructure frontend by feature domains:

```text
resources/js/features/
  chat/
  dashboard/
  admin/
  activity/
  shared/
```

For each feature:

- local API client
- local store/composable
- local types/selectors
- feature tests close to feature code

Keep Pinia, but split monolithic stores into domain stores + orchestration composables.

## 3.6 Contract-first development

Adopt versioned contracts for:

- webhook normalized events
- task payload/result schemas
- external API resources

Add contract tests that validate module adapters against these schemas, reducing full end-to-end dependence for every change.

---

## 4. Delivery Architecture Changes (Process + Tooling)

## 4.1 Fast/Full verification lanes

Implement two mandatory lanes:

- `Fast Lane` (module-scoped tests + static checks + changed-contract validation)
- `Full Lane` (existing full suite, required pre-merge to protected branches)

Use changed-path mapping to run only relevant module tests in Fast Lane.

## 4.2 Architecture fitness functions (automated)

Add checks that fail CI if:

- module imports cross forbidden boundaries
- controller directly calls infrastructure in another module
- non-contract events are emitted across modules
- module exceeds agreed complexity/file-size thresholds

## 4.3 Inner-loop runtime profiles

Define explicit modes:

- `dev-fast`: no Octane/long-lived workers; maximum code reload speed
- `dev-parity`: Octane + queue topology + reverb parity checks

Use `dev-fast` for feature iteration and `dev-parity` before merge.

---

## 5. Phased Migration Plan

## Phase 0 (1 week): Baseline + guardrails

- Create `app/Modules` skeleton and module boundaries document.
- Add import boundary checks (PHPStan custom rule + ESLint import boundaries).
- Define contract schemas for events/task results.

## Phase 1 (2-3 weeks): Orchestration kernel extraction

- Extract intent/task/result registries from current routing/dispatch flow.
- Wrap existing logic in adapters so behavior is unchanged.
- Add characterization tests on current flow before moving logic.

## Phase 2 (2-3 weeks): GitLab + Alert + Agent decomposition

- Split `GitLabClient` into capability adapters behind `GitLabPort`.
- Split `AlertEventService` into independent rule evaluators (`AlertRule` interface + registry).
- Split `VunnixAgent` prompt/tool assembly into composable providers per concern.

## Phase 3 (2 weeks): Frontend feature slicing

- Move chat/admin/dashboard code into `resources/js/features/*`.
- Break `conversations` and `admin` stores into smaller domain stores.
- Introduce feature-level test helpers and contract mocks.

## Phase 4 (1-2 weeks): CI lane optimization

- Add Fast Lane changed-path matrix.
- Keep Full Lane unchanged initially; then tune with historical timing data.

---

## 6. Success Metrics (Must Be Measured)

Target after migration:

- 60%+ of feature PRs touch only one backend module and one frontend feature slice.
- Median files changed per feature reduced by >=40%.
- Fast Lane CI under 10 minutes for localized changes.
- Reopened regressions per feature reduced by >=30%.
- Lead time from “task start” to merged PR improved by >=3x for small/medium changes.

---

## 7. Risks and Mitigations

- Risk: over-abstracting too early.  
  Mitigation: migrate by seams using adapters; keep behavior locked with characterization tests.

- Risk: temporary double-structure complexity.  
  Mitigation: time-box each phase and delete old paths immediately after parity is proven.

- Risk: contract drift across modules.  
  Mitigation: schema-versioned events + contract tests in CI.

---

## 8. Decisions

- Keep deployment topology as-is in this cycle (single deployable).
- Prioritize **codebase architecture and delivery architecture** over infrastructure split.
- Sequence migration around highest-churn hotspots first:
  - orchestration path
  - GitLab integration
  - chat/admin frontend domains

This approach gives the fastest path to 3x iteration speed with minimal operational risk.
